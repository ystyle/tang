package middleware_showcase

import std.collection.HashMap
import std.collection.ArrayList
import std.time.DateTime
import stdx.log.LogLevel
import stdx.encoding.hex.{fromHexString, toHexString}
import tang.*

// å¯¼å…¥æ‰€æœ‰ä¸­é—´ä»¶
import tang.middleware.exception.recovery
import tang.middleware.accesslog.accesslog
import tang.middleware.requestid.requestid
import tang.middleware.cors.{newCors, withAllowAllOrigins, withAllowCredentials}
import tang.middleware.security.{security, withStrictSecurity}
import tang.middleware.staticfile.{staticFiles, withPrefix}
import tang.middleware.bodylimit.{bodyLimit, withMaxSize}
import tang.middleware.ratelimit.{rateLimit, withMaxRequests}

import tang.middleware.healthcheck.{healthcheck, withLivenessCheck, withReadinessCheck, withSystemInfo}
import tang.middleware.redirect.{redirect, redirectMiddleware}
import tang.middleware.favicon.favicon
import tang.middleware.timeout.{timeout, withTimeout, isTimeout}
import tang.middleware.keyauth.{keyAuth, withKey, withLookup}
import tang.middleware.rewrite.{createRewriteFunction}
import tang.middleware.cache.{cache, withDuration,withRules, withExcludePath, CacheRule}
import tang.middleware.etag.{etag, withWeak}
import tang.middleware.csrf.{csrf, withSecretKey, withExpiration, withExcludePath as csrfExcludePath}
import tang.middleware.session.{session, withExpiration as sessionExpiration, withCookieName, Session}
import tang.middleware.encryptcookie.{encryptCookie, withKeysFromHex, withExcludeCookie}
import tang.middleware.idempotency.{idempotency, withLifetime, withKeyHeader, IdempotencyStore, CachedResponse}
import tang.middleware.proxy.{proxy, withBackend, withStripPrefix, LoadBalanceStrategy}

main() {
    // åˆ›å»º Tang åº”ç”¨ï¼Œåº”ç”¨å…¨å±€ä¸­é—´ä»¶
    //
    // ä¸­é—´ä»¶æ‰§è¡Œé¡ºåºå¾ˆé‡è¦ï¼š
    // 1. recovery åº”è¯¥æ”¾åœ¨æœ€å¤–å±‚ï¼Œæ•è·æ‰€æœ‰å¼‚å¸¸
    // 2. accesslog è®°å½•è¯·æ±‚æ—¥å¿—
    // 3. requestid ç”Ÿæˆ/ä¼ é€’è¯·æ±‚ ID
    // 4. ratelimit é™åˆ¶è¯·æ±‚é€Ÿç‡ï¼ˆé˜²æ­¢ DDoSï¼‰
    // 5. bodylimit é™åˆ¶è¯·æ±‚ä½“å¤§å°ï¼ˆé˜²æ­¢å¤§æ–‡ä»¶æ”»å‡»ï¼‰
    // 6. cors å¤„ç†è·¨åŸŸè¯·æ±‚
    // 7. security æ·»åŠ å®‰å…¨å“åº”å¤´
    // 8. cache ç¼“å­˜æ§åˆ¶
    // 9. etag ç¼“å­˜éªŒè¯
    // æ³¨æ„ï¼šKeyAuth ä¸åœ¨å…¨å±€åº”ç”¨ï¼Œåœ¨ç‰¹å®šè·¯ç”±ä¸Šæµ‹è¯•
    let app = Tang([
        withHost("127.0.0.1"),
        withPort(10001u16),
        withShowBanner(),
        withShowRoutes()
    ])

    // åº”ç”¨å…¨å±€ä¸­é—´ä»¶
    app.use(favicon())                           // 0. Favicon å¤„ç†ï¼ˆä¼˜å…ˆçº§é«˜ï¼‰
    app.use(recovery())                          // 1. å¼‚å¸¸æ¢å¤ï¼ˆå¿…é¡»æ”¾åœ¨æœ€å¤–å±‚ï¼‰
    app.use(accesslog())                         // 2. è®¿é—®æ—¥å¿—
    app.use(requestid())
    app.use(rateLimit([                           // 4. é™æµï¼ˆæ¯åˆ†é’Ÿ 100 ä¸ªè¯·æ±‚ï¼‰
        withMaxRequests(100)
    ]))
    app.use(bodyLimit([                           // 5. è¯·æ±‚ä½“é™åˆ¶ï¼ˆæœ€å¤§ 10MBï¼‰
        withMaxSize(10 * 1024 * 1024)
    ]))
    app.use(newCors([                             // 6. CORS è·¨åŸŸæ”¯æŒ
        withAllowAllOrigins(),            //    å…è®¸æ‰€æœ‰æ¥æº
        withAllowCredentials()            //    å…è®¸æºå¸¦å‡­è¯
    ]))
    app.use(security([withStrictSecurity()]))     // 7. å®‰å…¨å¤´ï¼ˆä¸¥æ ¼ç­–ç•¥ï¼‰
    app.use(cache([                               // 8. Cache ç¼“å­˜æ§åˆ¶
        withDuration(3600),               //     é»˜è®¤ç¼“å­˜ 1 å°æ—¶
        withExcludePath("/test/nocache"), //     æ’é™¤æ‰‹åŠ¨è®¾ç½® header çš„è·¯å¾„
        withRules([
            CacheRule("/api/*", 0),       // API ä¸ç¼“å­˜
            CacheRule("/static/*", 86400) // é™æ€æ–‡ä»¶ç¼“å­˜ 1 å¤©
        ])
    ]))
    app.use(etag())                               // 9. ETag ç¼“å­˜éªŒè¯
    app.use(timeout(withTimeout(2000)))

    // æ·»åŠ è·¯å¾„é‡å†™è§„åˆ™ï¼ˆåœ¨è·¯ç”±åŒ¹é…ä¹‹å‰æ‰§è¡Œï¼‰
    app.addRewriteRule(createRewriteFunction("/api/v1/(.*)", "/api/v2/$1"))
    app.addRewriteRule(createRewriteFunction("/old/api/(.*)", "/api/$1"))

    // ============ æµ‹è¯•è·¯ç”± ============

    // åŸºç¡€è·¯ç”±ï¼šè¿”å›è¯·æ±‚ ID
app.get("/", { ctx =>
        let rid = ctx.requestid()
        let ridStr = match (rid) {
            case Some(v) => v
            case None => "none"
        }
        let body = #"Welcome to Tang Middleware Showcase!
            Request ID: ${ridStr}
            Available endpoints:
            - GET  /                      - Homepage
            - GET  /health                - Basic health check
            - GET  /health/full           - Full health check with system info
            - GET  /old-path              - Test redirect (301 -> /new-path)
            - GET  /new-path              - Redirect target
            - GET  /api/info              - API info
            - GET  /api/user              - Protected with KeyAuth (X-API-Key header)
            - GET  /api/data              - JSON response
            - GET  /api/error             - Test exception recovery
            - GET  /api/headers           - Show all request headers
            - GET  /api/delay             - Test slow response (1s)
            - GET  /api/slow              - Test timeout middleware
            - POST /api/upload            - Test body limit (max 10MB)
            - GET  /api/test-limit        - Test rate limit (100 req/min)
            - GET  /api/test-cache        - Test Cache & ETag middleware
            - GET  /old/api/info          - Test Rewrite middleware -> /api/info
            - GET  /static/*              - Static files (real files from public/)

            New Security Middlewares (Third Batch):
            - GET  /test/csrf/token       - Get CSRF token
            - POST /test/csrf/protected   - Test CSRF validation (needs token)
            - GET  /test/csrf/public      - Public endpoint (no CSRF)
            - POST /test/session/login    - Create session
            - GET  /test/session/profile  - Read session data
            - POST /test/session/logout   - Clear session
            - GET  /test/encryptcookie/*  - Test cookie encryption
            "#
        ctx.responseBuilder.body(body)
        println("Request ID: ${ridStr}")  // ä½¿ç”¨ ridStr é¿å…è­¦å‘Š
    })


    // ============ æ–°ä¸­é—´ä»¶æµ‹è¯•è·¯ç”±ï¼ˆå¾…è§£å†³æ¨¡å—å¯¼å‡ºé—®é¢˜ï¼‰===========
    // å¥åº·æ£€æŸ¥
app.get("/health", healthcheck())

    // å¸¦è‡ªå®šä¹‰æ£€æŸ¥çš„å¥åº·æ£€æŸ¥
app.get("/health/full", healthcheck([
        withLivenessCheck({ ctx => true }),
        withReadinessCheck({ ctx => true }),
        withSystemInfo()
    ]))

    // é‡å®šå‘æµ‹è¯•
app.get("/old-path", redirect(url: "/new-path", statusCode: 301))
app.get("/new-path", { ctx => ctx.responseBuilder.body("This is the new path!\n") })

    // è¶…æ—¶æµ‹è¯•
app.get("/api/slow", { ctx =>
        // æ¨¡æ‹Ÿæ…¢æ“ä½œ
        sleep(Duration.second * 1)

        // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
        if (isTimeout(ctx)) {
            ctx.responseBuilder.status(504).body("Request timeout\n")
            return
        }

        ctx.responseBuilder.body("Slow operation completed\n")
    })

    // ============ æ–°ä¸­é—´ä»¶æµ‹è¯•è·¯ç”± ============

    // ========== KeyAuth æµ‹è¯• ==========
    // å…¬å¼€ç«¯ç‚¹ï¼ˆä¸éœ€è¦è®¤è¯ï¼‰
app.get("/test/keyauth", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "This is a public endpoint"),
            ("auth", "not required"),
            ("test", "Try accessing /test/keyauth/protected with X-API-Key header")
        ]))
    })

    // å—ä¿æŠ¤ç«¯ç‚¹ï¼ˆéœ€è¦ KeyAuthï¼‰
    let protectedRoutes = r.group("/test/keyauth")
    protectedRoutes.use(
        keyAuth([
            withKey("test-secret-key-12345"),
            withLookup("header:X-API-Key")
        ])
    )

    protectedRoutes.get("/protected", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "You are authenticated!"),
            ("auth", "success"),
            ("info", "KeyAuth middleware is working correctly")
        ]))
    })

    // ========== Rewrite æµ‹è¯• ==========
    // Rewrite ä¸­é—´ä»¶å·²åœ¨å…¨å±€ä¸­é—´ä»¶ä¸­é…ç½®ï¼ˆç¬¬ 61-62 è¡Œï¼‰
    // è¿™é‡Œåªéœ€è¦æ³¨å†Œç›®æ ‡è·¯ç”±å³å¯

    // ========== Cache æµ‹è¯• ==========
app.get("/test/cache", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "This response is cached for 1 hour"),
            ("cache-control", "max-age=3600"),
            ("hint", "Check the Cache-Control response header")
        ]))
    })

app.get("/test/nocache", { ctx =>
        // æ‰‹åŠ¨è®¾ç½® Cache-Control headerï¼ˆä¸­é—´ä»¶å·²æ’é™¤æ­¤è·¯å¾„ï¼‰
        ctx.responseBuilder.header("Cache-Control", "no-store, no-cache, must-revalidate")
        ctx.json(HashMap<String, String>([
            ("message", "This response is not cached"),
            ("cache-control", "no-store")
        ]))
    })

    // ========== ETag æµ‹è¯• ==========
app.get("/test/etag", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "This response includes ETag header"),
            ("timestamp", "${DateTime.now()}"),
            ("etag", "Check the ETag response header"),
            ("hint", "ETag is generated from URL path and query params")
        ]))
    })

    // ========== CSRF æµ‹è¯• ==========
    // CSRF ä¸­é—´ä»¶è·¯ç”±ç»„
    let csrfRoutes = r.group("/test/csrf")
    csrfRoutes.use(csrf([
        withSecretKey("012345678901234567890123456789012"),  // 32 å­—èŠ‚ hex å¯†é’¥
        withExpiration(3600),  // 1 å°æ—¶è¿‡æœŸ
        csrfExcludePath("/test/csrf/public")  // å…¬å¼€ç«¯ç‚¹ä¸éœ€è¦ CSRF
    ]))

    // è°ƒè¯•ç«¯ç‚¹ï¼šæµ‹è¯• kvSet/kvGet
    csrfRoutes.get("/debug", { ctx =>
        ctx.kvSet("debug_key", "debug_value")
        let value = ctx.kvGet<String>("debug_key")
        let valueStr = match (value) {
            case Some(v) => v
            case None => "none"
        }
        ctx.json(HashMap<String, String>([
            ("debug", "kvSet/kvGet test"),
            ("value", valueStr),
            ("path", ctx.path())
        ]))
    })

    // è·å– CSRF tokenï¼ˆGET è¯·æ±‚ä¼šç”Ÿæˆ tokenï¼‰
    csrfRoutes.get("/token", { ctx =>
        let token = ctx.kvGet<String>("csrf_token")
        let tokenStr = match (token) {
            case Some(t) => t
            case None => "no-token"
        }
        ctx.json(HashMap<String, String>([
            ("message", "CSRF token generated"),
            ("token", tokenStr),
            ("header", "X-CSRF-Token"),
            ("hint", "Include this token in X-CSRF-Token header for POST/PUT/DELETE requests")
        ]))
    })

    // æµ‹è¯• CSRF éªŒè¯ï¼ˆPOST è¯·æ±‚éœ€è¦ tokenï¼‰
    csrfRoutes.post("/protected", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "CSRF validation successful"),
            ("status", "authenticated"),
            ("info", "Your request included a valid CSRF token")
        ]))
    })

    // å…¬å¼€ç«¯ç‚¹ï¼ˆä¸éœ€è¦ CSRF tokenï¼‰
app.get("/test/csrf/public", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "This is a public endpoint"),
            ("csrf", "not required"),
            ("path", "excluded from CSRF protection")
        ]))
    })

    // æµ‹è¯•ï¼šç›´æ¥åœ¨è·¯ç”±ä¸Šåº”ç”¨ CSRF ä¸­é—´ä»¶
    let testCSRF = r.group("/test/csrf2")
    testCSRF.use(csrf([withSecretKey("test123456789012345678901234567890")]))
    testCSRF.get("/direct", { ctx =>
        let token = ctx.kvGet<String>("csrf_token")
        let tokenStr = match (token) {
            case Some(t) => t
            case None => "no-token"
        }
        ctx.json(HashMap<String, String>([
            ("test", "direct middleware application"),
            ("token", tokenStr)
        ]))
    })

    // ========== Session æµ‹è¯• ==========
    // Session ä¸­é—´ä»¶è·¯ç”±ç»„
    let sessionRoutes = r.group("/test/session")
    sessionRoutes.use(session([
        sessionExpiration(3600),  // 1 å°æ—¶è¿‡æœŸ
        withCookieName("test_session")
    ]))

    // è®¾ç½® session
    sessionRoutes.post("/login", { ctx =>
        let sess = ctx.kvGet<Session>("session")
        if (let Some(s) <- sess) {
            s.data.set("userId", "12345")
            s.data.set("username", "testuser")
            s.data.set("loginTime", "${DateTime.now()}")
        }
        ctx.json(HashMap<String, String>(
            ("message", "Session created successfully"),
            ("action", "login"),
            ("hint", "Session data stored: userId, username, loginTime")
        ))
    })

    // è¯»å– session
    sessionRoutes.get("/profile", { ctx =>
        let sess = ctx.kvGet<Session>("session")
        if (let Some(s) <- sess) {
            let userId = s.data.get("userId") ?? "none"
            let username = s.data.get("username") ?? "none"
            let loginTime = s.data.get("loginTime") ?? "none"

            ctx.json(HashMap<String, String>([
                ("message", "Session retrieved successfully"),
                ("userId", userId),
                ("username", username),
                ("loginTime", loginTime),
                ("sessionId", s.id)
            ]))
        } else {
            ctx.json(HashMap<String, String>([
                ("message", "No session found"),
                ("hint", "POST /test/session/login first")
            ]))
        }
    })

    // æ¸…é™¤ session
    sessionRoutes.post("/logout", { ctx =>
        let sess = ctx.kvGet<Session>("session")
        if (let Some(s) <- sess) {
            s.data.clear()
        }
        ctx.json(HashMap<String, String>([
            ("message", "Session cleared successfully"),
            ("action", "logout")
        ]))
    })

    // ========== EncryptCookie æµ‹è¯• ==========
app.get("/test/encryptcookie/set", { ctx =>
        // ç”±äºå½“å‰æ¡†æ¶é™åˆ¶ï¼Œè¿™é‡Œåªå±•ç¤ºè¯´æ˜
        // å®é™…ä½¿ç”¨æ—¶éœ€è¦åœ¨åº”ç”¨è·¯ç”±å‰æ·»åŠ  encryptCookie ä¸­é—´ä»¶
        ctx.json(HashMap<String, String>([
            ("message", "EncryptCookie middleware demonstration"),
            ("encryption", "SM4-CBC + HMAC-SHA256"),
            ("format", "base64(iv+encrypted).hex(signature)"),
            ("usage", "Add encryptCookie middleware to your router"),
            ("hint", "See middleware/encryptcookie/encryptcookie.cj for usage examples")
        ]))
    })

app.get("/test/encryptcookie/get", { ctx =>
        // è¯»å– cookieï¼ˆä¼šè‡ªåŠ¨è§£å¯†ï¼‰
        let testCookie = ctx.cookie("test_cookie")
        let cookieValue = match (testCookie) {
            case Some(v) => v
            case None => "not-set"
        }

        ctx.json(HashMap<String, String>([
            ("message", "Cookie retrieved"),
            ("test_cookie", cookieValue),
            ("note", "EncryptCookie middleware auto-decrypts on read")
        ]))
    })

    // ========== Idempotency æµ‹è¯• ==========
    let idempotencyRoutes = r.group("/test/idempotency")
    idempotencyRoutes.use(idempotency([
        withKeyHeader("X-Idempotency-Key"),
        withLifetime(3600)  // 1 å°æ—¶
    ]))

    // æ¨¡æ‹Ÿæ”¯ä»˜æ¥å£ï¼ˆéœ€è¦å¹‚ç­‰æ€§ä¿æŠ¤ï¼‰
    idempotencyRoutes.post("/payment", { ctx =>
        // æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†è¿‡ï¼ˆä¸­é—´ä»¶å·²ç»æ£€æŸ¥è¿‡ç¼“å­˜ï¼Œè¿™é‡Œç›´æ¥å¤„ç†ï¼‰
        let keyOpt = ctx.kvGet<String>("idempotency_key")
        let storeOpt = ctx.kvGet<IdempotencyStore>("idempotency_store")

        // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
        let paymentId = "PAY-${DateTime.now().toUnixTimeStamp().toSeconds()}"
        let amount = "100.00"

        // æ„å»ºå“åº”
        let responseBody = """
        {"message":"Payment successful","paymentId":"${paymentId}","amount":"${amount}","status":"completed"}
        """

        // è¿”å›å“åº”
        ctx.responseBuilder.status(200u16)
        ctx.responseBuilder.body(responseBody)

        // ä¿å­˜åˆ°ç¼“å­˜ï¼ˆé¦–æ¬¡è¯·æ±‚ï¼‰
        if (let Some(key) <- keyOpt && let Some(store) <- storeOpt) {
            let cachedResponse = CachedResponse(200u16, responseBody)
            store.set(key, cachedResponse)
        }
    })

    // æ¨¡æ‹Ÿè®¢å•åˆ›å»ºï¼ˆéœ€è¦å¹‚ç­‰æ€§ä¿æŠ¤ï¼‰
    idempotencyRoutes.post("/order", { ctx =>
        let keyOpt = ctx.kvGet<String>("idempotency_key")
        let storeOpt = ctx.kvGet<IdempotencyStore>("idempotency_store")

        let orderId = "ORD-${DateTime.now().toUnixTimeStamp().toSeconds()}"
        let items = "item1,item2,item3"

        let responseBody = """
        {"message":"Order created","orderId":"${orderId}","items":"${items}","status":"pending","hint":"Send same request again with same key to test idempotency"}
        """

        ctx.responseBuilder.status(200u16)
        ctx.responseBuilder.body(responseBody)

        // ä¿å­˜åˆ°ç¼“å­˜ï¼ˆé¦–æ¬¡è¯·æ±‚ï¼‰
        if (let Some(key) <- keyOpt && let Some(store) <- storeOpt) {
            let cachedResponse = CachedResponse(200u16, responseBody)
            store.set(key, cachedResponse)
        }
    })

    // ä¸éœ€è¦å¹‚ç­‰æ€§çš„æ¥å£ï¼ˆGET è¯·æ±‚ï¼Œè‡ªåŠ¨æ’é™¤ï¼‰
    idempotencyRoutes.get("/info", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "This endpoint does not require idempotency key"),
            ("reason", "GET requests are automatically excluded"),
            ("usage", "POST endpoints require X-Idempotency-Key header")
        ]))
    })

    // ============ Proxy ä¸­é—´ä»¶æµ‹è¯• ============
    // Proxy æ¼”ç¤ºï¼šå°† /test/proxy/* è½¬å‘åˆ°æœ¬åœ° API
    // æ³¨æ„ï¼šéœ€è¦åœ¨ proxyRoutes ä¸‹æ³¨å†Œä¸€ä¸ª catch-all è·¯ç”±
    let proxyRoutes = r.group("/test/proxy")

    // åº”ç”¨ Proxy ä¸­é—´ä»¶ï¼ˆä»£ç†åˆ°æœ¬åœ° APIï¼‰
    proxyRoutes.use(proxy([
        withBackend("http://localhost:10001"),  // ä»£ç†åˆ°æœ¬åœ°æœåŠ¡å™¨
        withStripPrefix("/test/proxy")           // ç§»é™¤ /test/proxy å‰ç¼€
    ]))

    // æ³¨å†Œ catch-all è·¯ç”±ï¼Œè®© Proxy ä¸­é—´ä»¶å¤„ç†æ‰€æœ‰è¯·æ±‚
    proxyRoutes.all("/*", { ctx =>
        // è¿™ä¸ª handler å®é™…ä¸Šä¸ä¼šè¢«æ‰§è¡Œåˆ°
        // å› ä¸º Proxy ä¸­é—´ä»¶ä¼šè½¬å‘è¯·æ±‚å¹¶è¿”å›å“åº”
        ctx.responseBuilder.status(404u16).body("Proxy: No route configured")
    })

    // Favicon æµ‹è¯• - ç›´æ¥è·¯ç”±å¤„ç†å™¨
app.get("/favicon.ico", { ctx =>
        // 1x1 é€æ˜ GIF
        let gifData = Array<UInt8>(35, { i =>
            [0x47u8, 0x49u8, 0x46u8, 0x38u8, 0x39u8, 0x61u8, 0x01u8, 0x00u8,
             0x01u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x21u8, 0xF9u8, 0x04u8,
             0x01u8, 0x00u8, 0x00u8, 0x00u8, 0x00u8, 0x2Cu8, 0x00u8, 0x00u8,
             0x00u8, 0x00u8, 0x01u8, 0x00u8, 0x01u8, 0x00u8, 0x00u8, 0x02u8,
             0x02u8, 0x04u8, 0x01u8, 0x00u8, 0x3Bu8][i]
        })
        ctx.responseBuilder.status(200u16)
        ctx.responseBuilder.header("Content-Type", "image/x-icon")
        ctx.responseBuilder.header("Cache-Control", "public, max-age=86400")
        ctx.responseBuilder.body(gifData)
    })

    // ============ åŸæœ‰ API è·¯ç”± ============

    // API ä¿¡æ¯è·¯ç”±
app.get("/api/info", { ctx =>
        let rid = ctx.requestid()
        let ridStr = rid ?? "unknown"
        let clientIP = ctx.request.headers.getFirst("X-Real-IP") ?? ctx.request.headers.getFirst("X-Forwarded-For") ?? ctx.request.remoteAddr

        ctx.json(HashMap<String, String>([
            ("framework", "Tang"),
            ("language", "Cangjie"),
            ("version", "0.1.0"),
            ("requestId", ridStr),
            ("clientIP", clientIP)
        ]))
    })

    // åˆ›å»º API åˆ†ç»„
    let api = r.group("/api")

    // Rewrite æµ‹è¯•è·¯ç”±ï¼š/api/v1/users -> /api/v2/users
    api.get("/v2/users", { ctx =>
        ctx.json(HashMap<String, String>([
            ("users", "[]"),
            ("note", "This endpoint can be accessed via /api/v1/users (rewritten to /api/v2/users)")
        ]))
    })

    // Rewrite æµ‹è¯•è·¯ç”±ï¼š/old/api/data -> /api/data
    api.get("/data", { ctx =>
        ctx.json(HashMap<String, String>([
            ("message", "URL was rewritten from /old/api/data to /api/data"),
            ("original", "/old/api/data"),
            ("current", "/api/data"),
            ("middleware", "Rewrite is working!")
        ]))
    })

    api.get("/test-cache", { ctx =>
        // æµ‹è¯• Cache å’Œ ETag ä¸­é—´ä»¶
        let data = HashMap<String, String>([
            ("timestamp", "${DateTime.now()}"),
            ("message", "This response should have Cache-Control and ETag headers"),
            ("cache", "Check the Cache-Control header"),
            ("etag", "Check the ETag header")
        ])
        ctx.json(data)
    })

    // æµ‹è¯•å¼‚å¸¸æ¢å¤
    api.get("/error", { _ =>
        throw Exception("This is a test exception to demonstrate recovery middleware")
    })

    // æ˜¾ç¤ºæ‰€æœ‰è¯·æ±‚å¤´
    api.get("/headers", { ctx =>
        var headersInfo = ArrayList<String>()
        for ((name, values) in ctx.request.headers) {
            for (value in values) {
                headersInfo.add("${name}: ${value}")
            }
        }
        ctx.responseBuilder.body(String.join(headersInfo.toArray(), delimiter: "\n"))
    })

    // æµ‹è¯•æ…¢å“åº”ï¼ˆç”¨äºæµ‹è¯• accesslog çš„å»¶è¿Ÿè®°å½•ï¼‰
    api.get("/delay", { ctx =>
        // æ¨¡æ‹Ÿä¸€äº›å¤„ç†æ—¶é—´
        sleep(Duration.second) // ç¡çœ  1 ç§’
        ctx.responseBuilder.body("This request took about 1 second to process\n")
    })

    // æµ‹è¯•è¯·æ±‚ä½“é™åˆ¶
    api.post("/upload", { ctx =>
        ctx.responseBuilder.body("Upload endpoint (max 10MB)\n")
    })

    // æµ‹è¯•é™æµ
    api.get("/test-limit", { ctx =>
        ctx.responseBuilder.body("If you see this, rate limit is working (100 req/min)\n")
    })

    // é™æ€æ–‡ä»¶æœåŠ¡ï¼ˆä» public ç›®å½•æä¾›æ–‡ä»¶ï¼‰
    // ä½¿ç”¨ç»å¯¹è·¯å¾„é¿å…å·¥ä½œç›®å½•é—®é¢˜
app.get("/static/*", staticFiles("/home/ystyle/Code/CangJie/online/tang/examples/middleware_showcase/public", [withPrefix("/static")]))
app.get("/static", staticFiles("/home/ystyle/Code/CangJie/online/tang/examples/middleware_showcase/public", [withPrefix("/static")]))

    // ä¸ºæ‰€æœ‰è·¯å¾„æ·»åŠ  OPTIONS å¤„ç†å™¨ï¼Œè®© CORS ä¸­é—´ä»¶èƒ½å¤Ÿå¤„ç†é¢„æ£€è¯·æ±‚
    // æ³¨æ„ï¼šéœ€è¦ä¸ºæ¯ä¸ªè·¯å¾„å‰ç¼€æ³¨å†Œ OPTIONS è·¯ç”±ï¼Œå› ä¸º radix tree çš„ /* åªåŒ¹é…å•å±‚è·¯å¾„
app.options("/*", { ctx =>
        ctx.responseBuilder.body("")
    })
    api.options("/*", { ctx =>
        ctx.responseBuilder.body("")
    })

    // ============ å¯åŠ¨æœåŠ¡å™¨ ============

    println("========================================")
    println("  Tang Middleware Showcase Server")
    println("========================================")
    println("")
    println("Server running at: http://localhost:10001")
    println("")
    println("ğŸ” Middleware Testing Guide:")
    println("")
    println("[KeyAuth Test]")
    println("  curl http://localhost:10001/test/keyauth")
    println("  curl -H 'X-API-Key: test-secret-key-12345' http://localhost:10001/test/keyauth/protected")
    println("")
    println("[Rewrite Test]")
    println("  curl http://localhost:10001/old/api/data")
    println("  curl http://localhost:10001/api/v1/users")
    println("")
    println("[Cache Test]")
    println("  curl -I http://localhost:10001/test/cache")
    println("  curl -I http://localhost:10001/test/nocache")
    println("")
    println("[ETag Test]")
    println("  curl -I http://localhost:10001/test/etag")
    println("")
    println("========== New Security Middlewares (Third Batch) ==========")
    println("")
    println("[CSRF Test]")
    println("  # 1. Get CSRF token")
    println("  curl http://localhost:10001/test/csrf/token")
    println("")
    println("  # 2. Use token in protected endpoint")
    println("  curl -H 'X-CSRF-Token: <token>' http://localhost:10001/test/csrf/protected")
    println("")
    println("  # 3. Public endpoint (no token needed)")
    println("  curl http://localhost:10001/test/csrf/public")
    println("")
    println("[Session Test]")
    println("  # 1. Create session")
    println("  curl -c cookies.txt http://localhost:10001/test/session/login -X POST")
    println("")
    println("  # 2. Read session")
    println("  curl -b cookies.txt http://localhost:10001/test/session/profile")
    println("")
    println("  # 3. Clear session")
    println("  curl -b cookies.txt http://localhost:10001/test/session/logout -X POST")
    println("")
    println("[EncryptCookie Test]")
    println("  # Note: Due to framework limitations, this is a demonstration endpoint")
    println("  curl http://localhost:10001/test/encryptcookie/set")
    println("")
    println("========== New Advanced Middlewares (Fourth Batch) ==========")
    println("")
    println("[Idempotency Test]")
    println("  # 1. GET request (no idempotency key needed)")
    println("  curl http://localhost:10001/test/idempotency/info")
    println("")
    println("  # 2. First payment request (with idempotency key)")
    println("  curl -H 'X-Idempotency-Key: unique-key-123' -X POST http://localhost:10001/test/idempotency/payment")
    println("")
    println("  # 3. Second request with same key (should return cached response)")
    println("  curl -H 'X-Idempotency-Key: unique-key-123' -X POST http://localhost:10001/test/idempotency/payment")
    println("")
    println("  # 4. Order creation test")
    println("  curl -H 'X-Idempotency-Key: order-key-456' -X POST http://localhost:10001/test/idempotency/order")
    println("")
    println("[Proxy Test]")
    println("  # 1. Proxy GET request (forwards to /api/info)")
    println("  curl http://localhost:10001/test/proxy/api/info")
    println("")
    println("  # 2. Proxy POST request")
    println("  curl -X POST -H 'Content-Type: application/json' -d '{\"test\":\"data\"}' http://localhost:10001/test/proxy/api/test-cache")
    println("")
    println("  # 3. WebSocket Upgrade test (should return 426 error)")
    println("  curl -H 'Upgrade: websocket' http://localhost:10001/test/proxy/api/info")
    println("")
    println("Press Ctrl+C to stop the server")
    println("========================================")
    println("")

    // å¯åŠ¨åº”ç”¨
    app.listen()
}
